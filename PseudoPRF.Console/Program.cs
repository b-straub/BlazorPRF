using System.Text.Json;
using BlazorPRF.Crypto;
using BlazorPRF.Shared.Formatting;
using BlazorPRF.Shared.Json;
using PseudoPRF.Services;

var debugMode = args.Contains("--debug");

if (args.Length == 0)
{
    ShowHelp();
    return 0;
}

var command = args[0].ToLowerInvariant();

return command switch
{
    "keygen" => KeyGen(args),
    "keygen-ed25519" => KeyGenEd25519(args),
    "keygen-dual" => KeyGenDual(args),
    "encrypt" => Encrypt(args, debugMode),
    "decrypt" => Decrypt(args, debugMode),
    "encrypt-sym" => EncryptSymmetric(args),
    "decrypt-sym" => DecryptSymmetric(args),
    "sign" => Sign(args),
    "verify" => Verify(args),
    _ => ShowHelp()
};

static int ShowHelp()
{
    Console.WriteLine("""
        PseudoPRF - X25519/ChaCha20-Poly1305 Encryption & Ed25519 Signing Tool

        Usage: pseudoprf <command> [options]

        Key Generation:
          keygen                    Generate X25519 encryption key pair
          keygen-ed25519            Generate Ed25519 signing key pair
          keygen-dual               Generate both X25519 and Ed25519 key pairs

        Encryption (X25519 + ChaCha20-Poly1305):
          encrypt <pubkey> <msg>    Encrypt message to recipient's public key
          decrypt <privkey> [msg]   Decrypt message with private key
          encrypt-sym <key> <msg>   Symmetric encrypt with 32-byte key
          decrypt-sym <key> [msg]   Symmetric decrypt with 32-byte key

        Signing (Ed25519):
          sign <privkey> <msg>      Sign message with Ed25519 private key
          verify <pubkey> <sig> <msg>  Verify Ed25519 signature

        Options:
          --armor                   Use PFA ASCII armor format
          --json                    Output as JSON (default for messages)
          --stdin                   Read from stdin
          --debug                   Show intermediate crypto values (hex)

        Examples:
          pseudoprf keygen --armor
          pseudoprf keygen-ed25519
          pseudoprf keygen-dual
          pseudoprf encrypt "BASE64_PUBLIC_KEY" "Hello, World!"
          pseudoprf decrypt "BASE64_PRIVATE_KEY" '{"ephemeralPublicKey":"...","ciphertext":"...","nonce":"..."}'
          pseudoprf sign "BASE64_ED25519_PRIVATE_KEY" "Hello, World!"
          pseudoprf verify "BASE64_ED25519_PUBLIC_KEY" "SIGNATURE" "Hello, World!"
        """);
    return 0;
}

static int KeyGen(string[] args)
{
    var useArmor = args.Contains("--armor");
    var keyPair = KeyGenerator.GenerateKeyPair();

    if (useArmor)
    {
        var metadata = new PublicKeyMetadata
        {
            Created = DateOnly.FromDateTime(DateTime.UtcNow),
            Comment = "Generated by PseudoPRF"
        };

        Console.WriteLine(PrfArmor.ArmorPrivateKey(keyPair.PrivateKeyBase64, metadata));
        Console.WriteLine();
        Console.WriteLine(PrfArmor.ArmorPublicKey(keyPair.PublicKeyBase64, metadata));
    }
    else
    {
        Console.WriteLine($"Private: {keyPair.PrivateKeyBase64}");
        Console.WriteLine($"Public:  {keyPair.PublicKeyBase64}");
    }

    return 0;
}

static int Encrypt(string[] args, bool debug)
{
    if (args.Length < 3)
    {
        Console.Error.WriteLine("Usage: pseudoprf encrypt <pubkey> <message>");
        return 1;
    }

    var publicKey = args[1];
    var message = args[2];
    var useArmor = args.Contains("--armor");

    // Handle armored public key
    if (PrfArmor.IsArmoredPublicKey(publicKey))
    {
        publicKey = PrfArmor.UnArmorPublicKey(publicKey) ?? publicKey;
    }

    if (debug)
    {
        Console.Error.WriteLine($"[DEBUG] Recipient public key (base64): {publicKey}");
        Console.Error.WriteLine($"[DEBUG] Recipient public key (hex): {Convert.ToHexString(Convert.FromBase64String(publicKey))}");
    }

    var result = PseudoPrfCrypto.EncryptAsymmetric(message, publicKey);

    if (!result.Success)
    {
        Console.Error.WriteLine($"Encryption failed: {result.Error}");
        return 1;
    }

    var json = JsonSerializer.Serialize(result.Value, SharedJsonContext.Default.EncryptedMessage);

    if (useArmor)
    {
        Console.WriteLine(PrfArmor.ArmorMessage(json));
    }
    else
    {
        Console.WriteLine(json);
    }

    return 0;
}

static int Decrypt(string[] args, bool debug)
{
    var useStdin = args.Contains("--stdin");

    if (args.Length < 2 || (!useStdin && args.Length < 3))
    {
        Console.Error.WriteLine("Usage: pseudoprf decrypt <privkey> <encrypted_message>");
        Console.Error.WriteLine("       pseudoprf decrypt <privkey> --stdin");
        return 1;
    }

    var privateKey = args[1];
    var encryptedInput = useStdin ? Console.In.ReadToEnd() : args[2];

    // Handle armored private key
    if (PrfArmor.IsArmoredPrivateKey(privateKey))
    {
        privateKey = PrfArmor.UnArmorPrivateKey(privateKey) ?? privateKey;
    }

    // Handle armored message
    string? messageJson = encryptedInput;
    if (PrfArmor.IsArmoredMessage(encryptedInput))
    {
        messageJson = PrfArmor.UnArmorMessage(encryptedInput);
        if (messageJson is null)
        {
            Console.Error.WriteLine("Failed to parse armored message");
            return 1;
        }
    }

    var encrypted = JsonSerializer.Deserialize(messageJson, SharedJsonContext.Default.EncryptedMessage);
    if (encrypted is null)
    {
        Console.Error.WriteLine("Failed to parse encrypted message JSON");
        return 1;
    }

    if (debug)
    {
        Console.Error.WriteLine($"[DEBUG] Private key (base64): {privateKey}");
        Console.Error.WriteLine($"[DEBUG] Private key (hex): {Convert.ToHexString(Convert.FromBase64String(privateKey))}");
        Console.Error.WriteLine($"[DEBUG] Ephemeral public key (base64): {encrypted.EphemeralPublicKey}");
        Console.Error.WriteLine($"[DEBUG] Ephemeral public key (hex): {Convert.ToHexString(Convert.FromBase64String(encrypted.EphemeralPublicKey))}");
    }

    var result = PseudoPrfCrypto.DecryptAsymmetric(encrypted, privateKey);

    if (!result.Success)
    {
        Console.Error.WriteLine($"Decryption failed: {result.Error}");
        return 1;
    }

    Console.WriteLine(result.Value);
    return 0;
}

static int EncryptSymmetric(string[] args)
{
    if (args.Length < 3)
    {
        Console.Error.WriteLine("Usage: pseudoprf encrypt-sym <key> <message>");
        return 1;
    }

    var key = args[1];
    var message = args[2];
    var useArmor = args.Contains("--armor");

    var result = PseudoPrfCrypto.EncryptSymmetric(message, key);

    if (!result.Success)
    {
        Console.Error.WriteLine($"Encryption failed: {result.Error}");
        return 1;
    }

    var json = JsonSerializer.Serialize(result.Value, SharedJsonContext.Default.SymmetricEncryptedMessage);

    if (useArmor)
    {
        Console.WriteLine(PrfArmor.ArmorMessage(json));
    }
    else
    {
        Console.WriteLine(json);
    }

    return 0;
}

static int DecryptSymmetric(string[] args)
{
    var useStdin = args.Contains("--stdin");

    if (args.Length < 2 || (!useStdin && args.Length < 3))
    {
        Console.Error.WriteLine("Usage: pseudoprf decrypt-sym <key> <encrypted_message>");
        Console.Error.WriteLine("       pseudoprf decrypt-sym <key> --stdin");
        return 1;
    }

    var key = args[1];
    var encryptedInput = useStdin ? Console.In.ReadToEnd() : args[2];

    // Handle armored message
    string? messageJson = encryptedInput;
    if (PrfArmor.IsArmoredMessage(encryptedInput))
    {
        messageJson = PrfArmor.UnArmorMessage(encryptedInput);
        if (messageJson is null)
        {
            Console.Error.WriteLine("Failed to parse armored message");
            return 1;
        }
    }

    var encrypted = JsonSerializer.Deserialize(messageJson, SharedJsonContext.Default.SymmetricEncryptedMessage);
    if (encrypted is null)
    {
        Console.Error.WriteLine("Failed to parse encrypted message JSON");
        return 1;
    }

    var result = PseudoPrfCrypto.DecryptSymmetric(encrypted, key);

    if (!result.Success)
    {
        Console.Error.WriteLine($"Decryption failed: {result.Error}");
        return 1;
    }

    Console.WriteLine(result.Value);
    return 0;
}

// ============================================================
// ED25519 SIGNING COMMANDS
// ============================================================

static int KeyGenEd25519(string[] args)
{
    var keyPair = KeyGenerator.GenerateEd25519KeyPair();

    Console.WriteLine($"Private (seed): {keyPair.PrivateKeyBase64}");
    Console.WriteLine($"Public:         {keyPair.PublicKeyBase64}");

    return 0;
}

static int KeyGenDual(string[] args)
{
    // Generate a random seed and derive both key types
    var seed = new byte[32];
    System.Security.Cryptography.RandomNumberGenerator.Fill(seed);
    var dualKeys = KeyGenerator.DeriveDualKeyPair(seed);

    Console.WriteLine("=== X25519 (Encryption) ===");
    Console.WriteLine($"Private: {dualKeys.X25519PrivateKey}");
    Console.WriteLine($"Public:  {dualKeys.X25519PublicKey}");
    Console.WriteLine();
    Console.WriteLine("=== Ed25519 (Signing) ===");
    Console.WriteLine($"Private: {dualKeys.Ed25519PrivateKey}");
    Console.WriteLine($"Public:  {dualKeys.Ed25519PublicKey}");

    return 0;
}

static int Sign(string[] args)
{
    var useStdin = args.Contains("--stdin");

    if (args.Length < 2 || (!useStdin && args.Length < 3))
    {
        Console.Error.WriteLine("Usage: pseudoprf sign <privkey> <message>");
        Console.Error.WriteLine("       pseudoprf sign <privkey> --stdin");
        return 1;
    }

    var privateKey = args[1];
    var message = useStdin ? Console.In.ReadToEnd().TrimEnd() : args[2];

    var result = CryptoOperations.Sign(message, privateKey);

    if (!result.Success)
    {
        Console.Error.WriteLine($"Signing failed: {result.Error}");
        return 1;
    }

    Console.WriteLine(result.Value);
    return 0;
}

static int Verify(string[] args)
{
    if (args.Length < 4)
    {
        Console.Error.WriteLine("Usage: pseudoprf verify <pubkey> <signature> <message>");
        return 1;
    }

    var publicKey = args[1];
    var signature = args[2];
    var message = args[3];

    var isValid = CryptoOperations.Verify(message, signature, publicKey);

    if (isValid)
    {
        Console.WriteLine("Signature is VALID");
        return 0;
    }
    else
    {
        Console.Error.WriteLine("Signature is INVALID");
        return 1;
    }
}
