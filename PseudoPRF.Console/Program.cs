using System.Text.Json;
using BlazorPRF.Crypto;
using BlazorPRF.Shared.Formatting;
using BlazorPRF.Shared.Json;
using PseudoPRF.Services;

var debugMode = args.Contains("--debug");

if (args.Length == 0)
{
    ShowHelp();
    return 0;
}

var command = args[0].ToLowerInvariant();

return command switch
{
    "keygen" => KeyGen(args),
    "encrypt" => Encrypt(args, debugMode),
    "decrypt" => Decrypt(args, debugMode),
    "encrypt-sym" => EncryptSymmetric(args),
    "decrypt-sym" => DecryptSymmetric(args),
    _ => ShowHelp()
};

static int ShowHelp()
{
    Console.WriteLine("""
        PseudoPRF - X25519/ChaCha20-Poly1305 Encryption Tool

        Usage: pseudoprf <command> [options]

        Commands:
          keygen                    Generate a new X25519 key pair
          encrypt <pubkey> <msg>    Encrypt message to recipient's public key
          decrypt <privkey> [msg]   Decrypt message with private key
          encrypt-sym <key> <msg>   Symmetric encrypt with 32-byte key
          decrypt-sym <key> [msg]   Symmetric decrypt with 32-byte key

        Options:
          --armor                   Use PFA ASCII armor format
          --json                    Output as JSON (default for messages)
          --stdin                   Read encrypted message from stdin (for decrypt commands)
          --debug                   Show intermediate crypto values (hex)

        Examples:
          pseudoprf keygen --armor
          pseudoprf encrypt "BASE64_PUBLIC_KEY" "Hello, World!"
          pseudoprf decrypt "BASE64_PRIVATE_KEY" '{"ephemeralPublicKey":"...","ciphertext":"...","nonce":"..."}'
          echo '...' | pseudoprf decrypt "BASE64_PRIVATE_KEY" --stdin
        """);
    return 0;
}

static int KeyGen(string[] args)
{
    var useArmor = args.Contains("--armor");
    var keyPair = KeyGenerator.GenerateKeyPair();

    if (useArmor)
    {
        var metadata = new PublicKeyMetadata
        {
            Created = DateOnly.FromDateTime(DateTime.UtcNow),
            Comment = "Generated by PseudoPRF"
        };

        Console.WriteLine(PrfArmor.ArmorPrivateKey(keyPair.PrivateKeyBase64, metadata));
        Console.WriteLine();
        Console.WriteLine(PrfArmor.ArmorPublicKey(keyPair.PublicKeyBase64, metadata));
    }
    else
    {
        Console.WriteLine($"Private: {keyPair.PrivateKeyBase64}");
        Console.WriteLine($"Public:  {keyPair.PublicKeyBase64}");
    }

    return 0;
}

static int Encrypt(string[] args, bool debug)
{
    if (args.Length < 3)
    {
        Console.Error.WriteLine("Usage: pseudoprf encrypt <pubkey> <message>");
        return 1;
    }

    var publicKey = args[1];
    var message = args[2];
    var useArmor = args.Contains("--armor");

    // Handle armored public key
    if (PrfArmor.IsArmoredPublicKey(publicKey))
    {
        publicKey = PrfArmor.UnArmorPublicKey(publicKey) ?? publicKey;
    }

    if (debug)
    {
        Console.Error.WriteLine($"[DEBUG] Recipient public key (base64): {publicKey}");
        Console.Error.WriteLine($"[DEBUG] Recipient public key (hex): {Convert.ToHexString(Convert.FromBase64String(publicKey))}");
    }

    var result = PseudoPrfCrypto.EncryptAsymmetric(message, publicKey);

    if (!result.Success)
    {
        Console.Error.WriteLine($"Encryption failed: {result.Error}");
        return 1;
    }

    var json = JsonSerializer.Serialize(result.Value, SharedJsonContext.Default.EncryptedMessage);

    if (useArmor)
    {
        Console.WriteLine(PrfArmor.ArmorMessage(json));
    }
    else
    {
        Console.WriteLine(json);
    }

    return 0;
}

static int Decrypt(string[] args, bool debug)
{
    var useStdin = args.Contains("--stdin");

    if (args.Length < 2 || (!useStdin && args.Length < 3))
    {
        Console.Error.WriteLine("Usage: pseudoprf decrypt <privkey> <encrypted_message>");
        Console.Error.WriteLine("       pseudoprf decrypt <privkey> --stdin");
        return 1;
    }

    var privateKey = args[1];
    var encryptedInput = useStdin ? Console.In.ReadToEnd() : args[2];

    // Handle armored private key
    if (PrfArmor.IsArmoredPrivateKey(privateKey))
    {
        privateKey = PrfArmor.UnArmorPrivateKey(privateKey) ?? privateKey;
    }

    // Handle armored message
    string? messageJson = encryptedInput;
    if (PrfArmor.IsArmoredMessage(encryptedInput))
    {
        messageJson = PrfArmor.UnArmorMessage(encryptedInput);
        if (messageJson is null)
        {
            Console.Error.WriteLine("Failed to parse armored message");
            return 1;
        }
    }

    var encrypted = JsonSerializer.Deserialize(messageJson, SharedJsonContext.Default.EncryptedMessage);
    if (encrypted is null)
    {
        Console.Error.WriteLine("Failed to parse encrypted message JSON");
        return 1;
    }

    if (debug)
    {
        Console.Error.WriteLine($"[DEBUG] Private key (base64): {privateKey}");
        Console.Error.WriteLine($"[DEBUG] Private key (hex): {Convert.ToHexString(Convert.FromBase64String(privateKey))}");
        Console.Error.WriteLine($"[DEBUG] Ephemeral public key (base64): {encrypted.EphemeralPublicKey}");
        Console.Error.WriteLine($"[DEBUG] Ephemeral public key (hex): {Convert.ToHexString(Convert.FromBase64String(encrypted.EphemeralPublicKey))}");
    }

    var result = PseudoPrfCrypto.DecryptAsymmetric(encrypted, privateKey);

    if (!result.Success)
    {
        Console.Error.WriteLine($"Decryption failed: {result.Error}");
        return 1;
    }

    Console.WriteLine(result.Value);
    return 0;
}

static int EncryptSymmetric(string[] args)
{
    if (args.Length < 3)
    {
        Console.Error.WriteLine("Usage: pseudoprf encrypt-sym <key> <message>");
        return 1;
    }

    var key = args[1];
    var message = args[2];
    var useArmor = args.Contains("--armor");

    var result = PseudoPrfCrypto.EncryptSymmetric(message, key);

    if (!result.Success)
    {
        Console.Error.WriteLine($"Encryption failed: {result.Error}");
        return 1;
    }

    var json = JsonSerializer.Serialize(result.Value, SharedJsonContext.Default.SymmetricEncryptedMessage);

    if (useArmor)
    {
        Console.WriteLine(PrfArmor.ArmorMessage(json));
    }
    else
    {
        Console.WriteLine(json);
    }

    return 0;
}

static int DecryptSymmetric(string[] args)
{
    var useStdin = args.Contains("--stdin");

    if (args.Length < 2 || (!useStdin && args.Length < 3))
    {
        Console.Error.WriteLine("Usage: pseudoprf decrypt-sym <key> <encrypted_message>");
        Console.Error.WriteLine("       pseudoprf decrypt-sym <key> --stdin");
        return 1;
    }

    var key = args[1];
    var encryptedInput = useStdin ? Console.In.ReadToEnd() : args[2];

    // Handle armored message
    string? messageJson = encryptedInput;
    if (PrfArmor.IsArmoredMessage(encryptedInput))
    {
        messageJson = PrfArmor.UnArmorMessage(encryptedInput);
        if (messageJson is null)
        {
            Console.Error.WriteLine("Failed to parse armored message");
            return 1;
        }
    }

    var encrypted = JsonSerializer.Deserialize(messageJson, SharedJsonContext.Default.SymmetricEncryptedMessage);
    if (encrypted is null)
    {
        Console.Error.WriteLine("Failed to parse encrypted message JSON");
        return 1;
    }

    var result = PseudoPrfCrypto.DecryptSymmetric(encrypted, key);

    if (!result.Success)
    {
        Console.Error.WriteLine($"Decryption failed: {result.Error}");
        return 1;
    }

    Console.WriteLine(result.Value);
    return 0;
}
