@using BlazorPRF.Shared.Crypto.Extensions
@using BlazorPRF.Persistence.Services
@inherits PrfModelComponent
@inject ISigningService SigningService
@inject IUserProfileService UserProfileService
@inject IClipboard Clipboard
@inject ISnackbar Snackbar
@inject NavigationManager NavigationManager

<MudCard>
    <MudCardHeader>
        <CardHeaderAvatar>
            <MudIcon Icon="@Icons.Material.Filled.PersonAdd" Color="Color.Primary" />
        </CardHeaderAvatar>
        <CardHeaderContent>
            <MudText Typo="Typo.h6">Invite Someone</MudText>
            <MudText Typo="Typo.body2" Class="mud-text-secondary">Create a signed invitation</MudText>
        </CardHeaderContent>
    </MudCardHeader>

    <MudCardContent>
        @if (Model is { HasKeys: false, RequiresOnDemandAuth: false })
        {
            <MudAlert Severity="Severity.Warning" Class="mb-4">
                Please authenticate first to create signed invites.
            </MudAlert>
        }

        @if (_signedInvite is null)
        {
            <MudText Typo="Typo.subtitle2" Class="mb-2">Your Identity (from profile)</MudText>

            <MudTextField Value="_myName"
                          Label="Your Name"
                          Variant="Variant.Filled"
                          Class="mb-2"
                          ReadOnly="true" />

            <MudTextField Value="_myEmail"
                          Label="Your Email"
                          Variant="Variant.Filled"
                          Class="mb-4"
                          ReadOnly="true" />

            <MudDivider Class="my-4" />

            <MudText Typo="Typo.subtitle2" Class="mb-2">Invitee</MudText>

            <EmailInput @bind-Value="_inviteeEmail"
                       @bind-IsValid="_inviteeEmailValid"
                       Label="Invitee Email"
                       Placeholder="bob@example.com"
                       HelperText="Email of the person you're inviting"
                       Disabled="@_isProcessing" />

            <MudButton Color="Color.Primary"
                       Variant="Variant.Filled"
                       StartIcon="@Icons.Material.Filled.Add"
                       OnClick="CreateInviteAsync"
                       Disabled="@(!CanCreate)">
                @if (_isProcessing)
                {
                    <MudProgressCircular Indeterminate="true" Size="Size.Small" Class="mr-2" />
                    <span>Creating...</span>
                }
                else
                {
                    <span>Create Signed Invite</span>
                }
            </MudButton>

            @if (_errorMessage is not null)
            {
                <MudAlert Severity="Severity.Error" Class="mt-4" Variant="Variant.Outlined">
                    @_errorMessage
                </MudAlert>
            }
        }
        else
        {
            <MudAlert Severity="Severity.Success" Class="mb-4" Icon="@Icons.Material.Filled.Check">
                Invite created for @_inviteeEmail
            </MudAlert>

            <MudText Typo="Typo.subtitle2" Class="mb-2">Next Steps:</MudText>
            <MudList T="string" Dense="true">
                <MudListItem Icon="@Icons.Material.Filled.Share" IconColor="Color.Primary">
                    Share the invite below with the invitee
                </MudListItem>
                <MudListItem Icon="@Icons.Material.Filled.Reply" IconColor="Color.Secondary">
                    They will sign and send back a response
                </MudListItem>
                <MudListItem Icon="@Icons.Material.Filled.Contacts" IconColor="Color.Tertiary">
                    Add them via Contacts â†’ "Add via Response"
                </MudListItem>
            </MudList>

            <MudPaper Class="pa-3 mt-4" Elevation="0" Outlined="true">
                <MudStack Row="true" AlignItems="AlignItems.Start" Justify="Justify.SpaceBetween">
                    <div Style="flex: 1; overflow: hidden;">
                        <MudText Typo="Typo.caption" Class="mud-text-secondary">Signed Invite</MudText>
                        <MudText Typo="Typo.body2" Style="font-family: monospace; word-break: break-all; white-space: pre-wrap; font-size: 0.7rem; max-height: 120px; overflow-y: auto;">
                            @_signedInvite
                        </MudText>
                    </div>
                    <MudTooltip Text="Copy to clipboard">
                        <MudIconButton Icon="@Icons.Material.Filled.ContentCopy"
                                       Color="Color.Primary"
                                       OnClick="CopyInviteAsync" />
                    </MudTooltip>
                </MudStack>
            </MudPaper>

            <MudButton Color="Color.Default"
                       Variant="Variant.Text"
                       StartIcon="@Icons.Material.Filled.Refresh"
                       OnClick="Reset"
                       Class="mt-4">
                Create Another Invite
            </MudButton>
        }
    </MudCardContent>
</MudCard>

@code {
    private string _myName = string.Empty;
    private string _myEmail = string.Empty;
    private string _inviteeEmail = string.Empty;
    private bool _inviteeEmailValid;
    private string? _signedInvite;
    private string? _errorMessage;
    private bool _isProcessing;
    private bool _profileLoaded;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        await LoadProfileAsync();
    }

    private async Task LoadProfileAsync()
    {
        if (_profileLoaded)
        {
            return;
        }

        // Try to load profile silently (don't trigger auth if not already authenticated)
        if (!Model.HasKeys && !Model.RequiresOnDemandAuth)
        {
            return;
        }

        // For on-demand auth, wait until user authenticates (don't prefetch)
        if (Model.RequiresOnDemandAuth && !Model.HasKeys)
        {
            return;
        }

        var result = await UserProfileService.GetAsync();
        if (result is { Success: true, Value: not null })
        {
            // Check if profile has required fields
            if (string.IsNullOrWhiteSpace(result.Value.Username) ||
                string.IsNullOrWhiteSpace(result.Value.Email))
            {
                Snackbar.Add("Please configure your profile first.", Severity.Info);
                NavigationManager.NavigateTo("settings");
                return;
            }

            _myName = result.Value.Username;
            _myEmail = result.Value.Email;
            _profileLoaded = true;
            StateHasChanged();
        }
        else if (result.Success && result.Value is null)
        {
            // No profile exists - redirect to settings
            Snackbar.Add("Please configure your profile first.", Severity.Info);
            NavigationManager.NavigateTo("settings");
        }
    }

    private bool CanCreate => (Model.HasKeys || Model.RequiresOnDemandAuth)
                              && !_isProcessing
                              && !string.IsNullOrWhiteSpace(_myName)
                              && !string.IsNullOrWhiteSpace(_myEmail)
                              && _myEmail.Contains('@')
                              && _inviteeEmailValid;

    private async Task CreateInviteAsync()
    {
        if (!CanCreate)
        {
            return;
        }

        _isProcessing = true;
        _errorMessage = null;
        _signedInvite = null;

        try
        {
            // Ensure keys are available (triggers WebAuthn if needed)
            if (!await Model.EnsureKeysAsync())
            {
                _errorMessage = "Authentication cancelled or failed";
                return;
            }

            // Generate random 8-character code
            var code = GenerateRandomCode(8);
            var timestamp = DateTimeExtensions.GetUnixSecondsNow();

            // Format: INV-{code}|{inviteeEmail}|{timestamp}
            var inviteCode = $"INV-{code}|{_inviteeEmail}|{timestamp}";

            var ed25519PublicKey = Model.Ed25519PublicKey;
            var x25519PublicKey = Model.PublicKey;

            if (string.IsNullOrEmpty(ed25519PublicKey) || string.IsNullOrEmpty(x25519PublicKey))
            {
                _errorMessage = "Keys not available. Please authenticate.";
                return;
            }

            // Sign the invite code
            var signResult = await SigningService.SignAsync(inviteCode, Model.Salt);

            if (signResult is { Success: true, Value: not null })
            {
                // Build signed invite with inviter identity for bidirectional trust
                var signedInvite = new SignedInvite(
                    inviteCode,
                    signResult.Value,
                    ed25519PublicKey,
                    x25519PublicKey,
                    _myName,
                    _myEmail);

                var json = System.Text.Json.JsonSerializer.Serialize(signedInvite, InviteJsonContext.Default.SignedInvite);
                _signedInvite = PrfArmor.ArmorSignedInvite(json);

                // Notify via reactive model - just set the property
                Model.InviteModel.LastInviteCreated = new InviteCreatedEventArgs
                {
                    InviteCode = inviteCode,
                    Email = _inviteeEmail,
                    ArmoredInvite = _signedInvite,
                    InviterEd25519PublicKey = ed25519PublicKey
                };
            }
            else
            {
                _errorMessage = signResult.Error ?? "Failed to sign invite";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Error: {ex.Message}";
        }
        finally
        {
            _isProcessing = false;
        }
    }

    private static string GenerateRandomCode(int length)
    {
        const string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        var random = new Random();
        var result = new char[length];
        for (var i = 0; i < length; i++)
        {
            result[i] = chars[random.Next(chars.Length)];
        }
        return new string(result);
    }

    private async Task CopyInviteAsync()
    {
        if (string.IsNullOrEmpty(_signedInvite))
        {
            return;
        }

        try
        {
            await Clipboard.SetTextAsync(_signedInvite);
            Snackbar.Add("Signed invite copied!", Severity.Success);
        }
        catch
        {
            Snackbar.Add("Failed to copy", Severity.Error);
        }
    }

    private void Reset()
    {
        _inviteeEmail = string.Empty;
        _signedInvite = null;
        _errorMessage = null;
        // Keep _myName and _myEmail for convenience when creating multiple invites
    }
}
