@using BlazorPRF.Shared.Extensions
@using BlazorPRF.Shared.Formatting
@inherits PrfModelComponent
@inject ISigningService SigningService
@inject IClipboard Clipboard
@inject ISnackbar Snackbar

<MudCard>
    <MudCardHeader>
        <CardHeaderAvatar>
            <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Color="Color.Secondary" />
        </CardHeaderAvatar>
        <CardHeaderContent>
            <MudText Typo="Typo.h6">Step 2: Accept Invite</MudText>
            <MudText Typo="Typo.body2" Class="mud-text-secondary">Sign your acceptance to prove identity</MudText>
        </CardHeaderContent>
    </MudCardHeader>

    <MudCardContent>
        @if (!Model.HasKeys && !Model.RequiresOnDemandAuth)
        {
            <MudAlert Severity="Severity.Warning" Class="mb-4">
                Please authenticate first using the main page.
            </MudAlert>
        }

        <MudTextField Value="_signedInviteInput"
                      ValueChanged="@((string v) => OnSignedInviteChanged(v))"
                      Label="Signed Invite"
                      Variant="Variant.Outlined"
                      Lines="6"
                      Class="mb-2"
                      Placeholder="Paste the armored signed invite from Step 1"
                      Style="font-family: monospace;"
                      Immediate="true"
                      Disabled="@_isProcessing" />

        @if (_inviteValid == true && _parsedEmail is not null)
        {
            <MudAlert Severity="Severity.Success" Class="mb-2" Variant="Variant.Outlined" Dense="true">
                <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center">
                    <MudIcon Icon="@Icons.Material.Filled.Verified" Size="Size.Small" />
                    <MudText Typo="Typo.body2">Valid invite for: <strong>@_parsedEmail</strong></MudText>
                </MudStack>
            </MudAlert>
        }
        else if (_inviteValid == false)
        {
            <MudAlert Severity="Severity.Error" Class="mb-2" Variant="Variant.Outlined" Dense="true">
                <MudText Typo="Typo.body2">Invalid invite signature - do not trust this invite!</MudText>
            </MudAlert>
        }

        <MudTextField @bind-Value="_username"
                      Label="Your Name"
                      Variant="Variant.Outlined"
                      Class="mb-4"
                      Placeholder="Bob Smith"
                      HelperText="Choose a display name for your public key"
                      Immediate="true"
                      Disabled="@_isProcessing" />

        <MudButton Color="Color.Secondary"
                   Variant="Variant.Filled"
                   StartIcon="@Icons.Material.Filled.Create"
                   OnClick="SignAcceptanceAsync"
                   Disabled="@(!CanSign)">
            @if (_isProcessing)
            {
                <MudProgressCircular Indeterminate="true" Size="Size.Small" Class="mr-2" />
                <span>Signing...</span>
            }
            else
            {
                <span>Sign Acceptance</span>
            }
        </MudButton>

        @if (_errorMessage is not null)
        {
            <MudAlert Severity="Severity.Error" Class="mt-4" Variant="Variant.Outlined">
                @_errorMessage
            </MudAlert>
        }

        @if (_signedResponse is not null)
        {
            <MudPaper Class="pa-4 mt-4" Elevation="0" Outlined="true">
                <MudStack Row="true" AlignItems="AlignItems.Start" Justify="Justify.SpaceBetween">
                    <div Style="flex: 1; overflow: hidden;">
                        <MudText Typo="Typo.caption" Class="mud-text-secondary">Signed Response (JSON)</MudText>
                        <MudText Typo="Typo.body2" Style="font-family: monospace; word-break: break-all; white-space: pre-wrap; font-size: 0.75rem;">
                            @_signedResponse
                        </MudText>
                    </div>
                    <MudTooltip Text="Copy to clipboard">
                        <MudIconButton Icon="@Icons.Material.Filled.ContentCopy"
                                       Color="Color.Secondary"
                                       OnClick="CopyResponseAsync" />
                    </MudTooltip>
                </MudStack>
                <MudText Typo="Typo.caption" Class="mud-text-secondary mt-2">
                    Send this response back to the inviter
                </MudText>
            </MudPaper>
        }
    </MudCardContent>
</MudCard>

@code {
    private string _signedInviteInput = string.Empty;
    private string _username = string.Empty;
    private string? _parsedEmail;
    private string? _parsedInviteCode;
    private string? _inviterSignature;
    private string? _inviterEd25519PublicKey;
    private bool? _inviteValid;
    private bool _isProcessing;
    private string? _errorMessage;
    private string? _signedResponse;

    private bool CanSign => (Model.HasKeys || Model.RequiresOnDemandAuth)
                            && !_isProcessing
                            && _inviteValid == true
                            && _parsedEmail is not null;

    private async void OnSignedInviteChanged(string value)
    {
        _signedInviteInput = value;
        _parsedEmail = null;
        _parsedInviteCode = null;
        _inviterSignature = null;
        _inviterEd25519PublicKey = null;
        _inviteValid = null;
        _errorMessage = null;

        if (string.IsNullOrWhiteSpace(value))
        {
            StateHasChanged();
            return;
        }

        try
        {
            // UnArmor if armored, otherwise try as raw JSON
            var json = PrfArmor.IsArmoredSignedInvite(value)
                ? PrfArmor.UnArmorSignedInvite(value)
                : value;

            if (json is null)
            {
                _inviteValid = false;
                StateHasChanged();
                return;
            }

            // Parse the signed invite JSON
            var signedInvite = System.Text.Json.JsonSerializer.Deserialize<SignedInvite>(json);

            if (signedInvite is null ||
                string.IsNullOrEmpty(signedInvite.inviteCode) ||
                string.IsNullOrEmpty(signedInvite.inviterSignature) ||
                string.IsNullOrEmpty(signedInvite.inviterEd25519PublicKey))
            {
                _inviteValid = false;
                StateHasChanged();
                return;
            }

            _parsedInviteCode = signedInvite.inviteCode;
            _inviterSignature = signedInvite.inviterSignature;
            _inviterEd25519PublicKey = signedInvite.inviterEd25519PublicKey;

            // Extract email from invite code
            var parts = signedInvite.inviteCode.Split('|');
            if (parts.Length == 3 && parts[0].StartsWith("INV-"))
            {
                _parsedEmail = parts[1];
            }
            else
            {
                _inviteValid = false;
                StateHasChanged();
                return;
            }

            // Verify the inviter's signature
            _inviteValid = await SigningService.VerifyAsync(
                signedInvite.inviteCode,
                signedInvite.inviterSignature,
                signedInvite.inviterEd25519PublicKey);

            StateHasChanged();
        }
        catch
        {
            _inviteValid = false;
            StateHasChanged();
        }
    }

    private async Task SignAcceptanceAsync()
    {
        if (!CanSign || _parsedEmail is null || _parsedInviteCode is null)
        {
            return;
        }

        _isProcessing = true;
        _errorMessage = null;
        _signedResponse = null;

        try
        {
            // Ensure keys are available (triggers WebAuthn if needed)
            if (!await Model.EnsureKeysAsync())
            {
                _errorMessage = "Authentication cancelled or failed";
                return;
            }

            var timestamp = DateTimeExtensions.GetUnixSecondsNow();
            var x25519PublicKey = Model.PublicKey;
            var ed25519PublicKey = Model.Ed25519PublicKey;

            if (string.IsNullOrEmpty(x25519PublicKey) || string.IsNullOrEmpty(ed25519PublicKey))
            {
                _errorMessage = "Keys not available. Please authenticate.";
                return;
            }

            // Build message to sign - include the original signed invite JSON for verification
            var messageToSign = $"{_signedInviteInput}|{x25519PublicKey}|{ed25519PublicKey}|{_username}|{_parsedEmail}|{timestamp}";

            // Sign the message
            var signResult = await SigningService.SignAsync(messageToSign, Model.Salt);

            if (signResult is { Success: true, Value: not null })
            {
                // Build JSON response - include the original signed invite
                var response = new
                {
                    signedInvite = new
                    {
                        inviteCode = _parsedInviteCode,
                        inviterSignature = _inviterSignature,
                        inviterEd25519PublicKey = _inviterEd25519PublicKey
                    },
                    username = _username,
                    email = _parsedEmail,
                    x25519PublicKey,
                    ed25519PublicKey,
                    timestamp,
                    message = messageToSign,
                    signature = signResult.Value
                };

                var json = System.Text.Json.JsonSerializer.Serialize(response);
                _signedResponse = PrfArmor.ArmorSignedResponse(json);
            }
            else if (signResult.ErrorCode == BlazorPRF.Shared.Models.PrfErrorCode.KeyDerivationFailed)
            {
                Model.OnKeyDerivationFailed();
                _errorMessage = "Keys expired. Please try again.";
            }
            else
            {
                _errorMessage = signResult.Error ?? "Signing failed";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Error: {ex.Message}";
        }
        finally
        {
            _isProcessing = false;
        }
    }

    private async Task CopyResponseAsync()
    {
        if (string.IsNullOrEmpty(_signedResponse))
        {
            return;
        }

        try
        {
            await Clipboard.SetTextAsync(_signedResponse);
            Snackbar.Add("Response copied!", Severity.Success);
        }
        catch
        {
            Snackbar.Add("Failed to copy", Severity.Error);
        }
    }

    private sealed class SignedInvite
    {
        public string? inviteCode { get; set; }
        public string? inviterSignature { get; set; }
        public string? inviterEd25519PublicKey { get; set; }
    }
}
