var c=new Map,d=null;function A(t){d=t}function o(t){let e=c.get(t);e?.expirationTimer&&clearTimeout(e.expirationTimer),c.delete(t)}function C(t,e){let n=setTimeout(()=>{o(t),d?.(t)},e),r=c.get(t);r&&(r.expirationTimer=n,r.expiresAt=Date.now()+e)}async function S(t){try{let e=window.location.hostname,n=document.title||e,r=crypto.getRandomValues(new Uint8Array(32)),i=await navigator.credentials.create({publicKey:{challenge:crypto.getRandomValues(new Uint8Array(32)),rp:{id:e,name:n},user:{id:r,name:t||`user-${Date.now()}`,displayName:t||"BlazorPRFBase User"},pubKeyCredParams:[{type:"public-key",alg:-7},{type:"public-key",alg:-257}],authenticatorSelection:{residentKey:"preferred",userVerification:"preferred"},extensions:{prf:{}}}});return i?i.getClientExtensionResults().prf?.enabled?JSON.stringify({success:!0,credentialId:u(new Uint8Array(i.rawId))}):JSON.stringify({success:!1,error:"PRF extension not supported by authenticator"}):JSON.stringify({success:!1,error:"Registration cancelled"})}catch(e){return JSON.stringify({success:!1,error:e.message})}}async function N(t,e,n){try{let r=a(t),i=a(e),s=await navigator.credentials.get({publicKey:{challenge:crypto.getRandomValues(new Uint8Array(32)),rpId:window.location.hostname,allowCredentials:[{type:"public-key",id:r}],userVerification:"preferred",extensions:{prf:{eval:{first:i}}}}});return s?await x(s,e,n):JSON.stringify({success:!1,error:"Authentication cancelled"})}catch(r){return JSON.stringify({success:!1,error:r.message})}}async function v(t,e){try{let n=a(t),r=await navigator.credentials.get({publicKey:{challenge:crypto.getRandomValues(new Uint8Array(32)),rpId:window.location.hostname,userVerification:"preferred",extensions:{prf:{eval:{first:n}}}}});return r?await x(r,t,e):JSON.stringify({success:!1,error:"Authentication cancelled"})}catch(n){return JSON.stringify({success:!1,error:n.message})}}async function x(t,e,n){let i=t.getClientExtensionResults().prf?.results?.first;if(!i)return JSON.stringify({success:!1,error:"PRF output not available"});let s=new Uint8Array(i),l=u(new Uint8Array(t.rawId)),f=await crypto.subtle.importKey("raw",s,"HKDF",!1,["deriveBits","deriveKey"]),m=await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:new TextEncoder().encode("BlazorPRFBase-encryption"),info:new TextEncoder().encode("aes-gcm-key")},f,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),h=await crypto.subtle.deriveBits({name:"HKDF",hash:"SHA-256",salt:new TextEncoder().encode("BlazorPRFBase-signing"),info:new TextEncoder().encode("ed25519-seed")},f,256),p=new Uint8Array(h),y=D(p),b=await crypto.subtle.importKey("pkcs8",y,{name:"Ed25519"},!1,["sign"]),w=await crypto.subtle.importKey("pkcs8",y,{name:"Ed25519"},!0,["sign"]),K=await crypto.subtle.exportKey("jwk",w),g=F(K.x);return p.fill(0),y.fill(0),o(e),c.set(e,{encryptionKey:m,signingKey:b,publicKeyBase64:g,credentialIdBase64:l,expiresAt:null,expirationTimer:null}),n!==null&&n>0&&C(e,n),JSON.stringify({success:!0,credentialId:l,publicKey:g})}function E(t){let e=c.get(t);return e?e.expiresAt!==null&&Date.now()>e.expiresAt?(o(t),!1):!0:!1}function O(t){let e=c.get(t);return e?e.expiresAt!==null&&Date.now()>e.expiresAt?(o(t),JSON.stringify({success:!1,error:"Keys expired"})):JSON.stringify({success:!0,credentialId:e.credentialIdBase64,publicKey:e.publicKeyBase64}):JSON.stringify({success:!1,error:"No cached keys"})}function P(t){o(t)}function J(){for(let t of c.keys())o(t)}async function k(t,e){try{let n=c.get(e);if(!n)return JSON.stringify({success:!1,error:"No cached encryption key - authenticate first"});if(n.expiresAt!==null&&Date.now()>n.expiresAt)return o(e),JSON.stringify({success:!1,error:"Keys expired - re-authenticate"});let r=a(t),i=crypto.getRandomValues(new Uint8Array(12)),s=await crypto.subtle.encrypt({name:"AES-GCM",iv:i},n.encryptionKey,r);return JSON.stringify({success:!0,ciphertext:u(new Uint8Array(s)),nonce:u(i)})}catch(n){return JSON.stringify({success:!1,error:n.message})}}async function U(t,e,n){try{let r=c.get(n);if(!r)return JSON.stringify({success:!1,error:"No cached encryption key - authenticate first"});if(r.expiresAt!==null&&Date.now()>r.expiresAt)return o(n),JSON.stringify({success:!1,error:"Keys expired - re-authenticate"});let i=a(t),s=a(e);if(s.length!==12)return JSON.stringify({success:!1,error:"Invalid nonce length - must be 12 bytes"});let l=await crypto.subtle.decrypt({name:"AES-GCM",iv:s},r.encryptionKey,i);return JSON.stringify({success:!0,plaintext:u(new Uint8Array(l))})}catch{return JSON.stringify({success:!1,error:"Decryption failed - authentication tag mismatch or wrong key"})}}async function I(t,e){try{let n=c.get(e);if(!n)return JSON.stringify({success:!1,error:"No cached signing key - authenticate first"});if(n.expiresAt!==null&&Date.now()>n.expiresAt)return o(e),JSON.stringify({success:!1,error:"Keys expired - re-authenticate"});let r=a(t),i=await crypto.subtle.sign({name:"Ed25519"},n.signingKey,r);return JSON.stringify({success:!0,signature:u(new Uint8Array(i))})}catch(n){return JSON.stringify({success:!1,error:n.message})}}async function B(t,e,n){try{let r=a(t),i=a(e),s=a(n),l=await crypto.subtle.importKey("raw",s,{name:"Ed25519"},!1,["verify"]);return await crypto.subtle.verify({name:"Ed25519"},l,i,r)}catch{return!1}}function R(){return typeof PublicKeyCredential<"u"&&typeof navigator.credentials<"u"}async function T(){return typeof PublicKeyCredential>"u"||typeof PublicKeyCredential.isConditionalMediationAvailable!="function"?!1:await PublicKeyCredential.isConditionalMediationAvailable()}function D(t){let e=new Uint8Array([48,46,2,1,0,48,5,6,3,43,101,112,4,34,4,32]),n=new Uint8Array(e.length+t.length);return n.set(e),n.set(t,e.length),n}function u(t){let e="";for(let n=0;n<t.length;n++)e+=String.fromCharCode(t[n]);return btoa(e)}function a(t){let e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;r++)n[r]=e.charCodeAt(r);return n}function F(t){return t.replace(/-/g,"+").replace(/_/g,"/").padEnd(t.length+(4-t.length%4)%4,"=")}var V={isPrfSupported:R,isConditionalMediationAvailable:T,register:S,authenticate:N,authenticateDiscoverable:v,hasCachedKeys:E,getCachedPublicInfo:O,clearCachedKeys:P,clearAllCachedKeys:J,encryptAesGcm:k,decryptAesGcm:U,ed25519Sign:I,ed25519Verify:B,setKeyExpiredCallback:A};export{V as BlazorPRFBase,N as authenticate,v as authenticateDiscoverable,J as clearAllCachedKeys,P as clearCachedKeys,U as decryptAesGcm,I as ed25519Sign,B as ed25519Verify,k as encryptAesGcm,O as getCachedPublicInfo,E as hasCachedKeys,T as isConditionalMediationAvailable,R as isPrfSupported,S as register,A as setKeyExpiredCallback};
