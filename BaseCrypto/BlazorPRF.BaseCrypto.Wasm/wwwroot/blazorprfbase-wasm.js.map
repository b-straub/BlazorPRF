{
  "version": 3,
  "sources": ["../TypeScript/src/baseprf.ts"],
  "sourcesContent": ["/**\n * BlazorPRFBase - Combined WebAuthn PRF + WebCrypto\n *\n * All cryptographic operations using browser-native SubtleCrypto API.\n * Private keys NEVER leave JavaScript - stored as non-extractable CryptoKey objects.\n */\n\n// ============================================================\n// KEY CACHE - Keeps CryptoKey objects in JS memory\n// ============================================================\n\ninterface CachedKeys {\n    encryptionKey: CryptoKey;   // AES-GCM, non-extractable\n    signingKey: CryptoKey;      // Ed25519, non-extractable\n    publicKeyBase64: string;    // Ed25519 public key - safe to share\n    credentialIdBase64: string; // Credential ID used\n    expiresAt: number | null;   // Unix timestamp or null for no expiry\n    expirationTimer: number | null;\n}\n\nconst keyCache = new Map<string, CachedKeys>();\n\n// Event callback for key expiration (called from JS, C# can subscribe)\nlet onKeyExpiredCallback: ((salt: string) => void) | null = null;\n\nexport function setKeyExpiredCallback(callback: (salt: string) => void): void {\n    onKeyExpiredCallback = callback;\n}\n\nfunction clearCacheEntry(salt: string): void {\n    const entry = keyCache.get(salt);\n    if (entry?.expirationTimer) {\n        clearTimeout(entry.expirationTimer);\n    }\n    keyCache.delete(salt);\n}\n\nfunction scheduleExpiration(salt: string, ttlMs: number): void {\n    const timer = setTimeout(() => {\n        clearCacheEntry(salt);\n        onKeyExpiredCallback?.(salt);\n    }, ttlMs) as unknown as number;\n\n    const entry = keyCache.get(salt);\n    if (entry) {\n        entry.expirationTimer = timer;\n        entry.expiresAt = Date.now() + ttlMs;\n    }\n}\n\n// ============================================================\n// WEBAUTHN PRF REGISTRATION\n// ============================================================\n\n/**\n * Register a new passkey with PRF extension support.\n * @returns JSON with credentialId (Base64) or error\n */\nexport async function register(displayName: string | null): Promise<string> {\n    try {\n        const rpId = window.location.hostname;\n        const rpName = document.title || rpId;\n        const userId = crypto.getRandomValues(new Uint8Array(32));\n\n        const credential = await navigator.credentials.create({\n            publicKey: {\n                challenge: crypto.getRandomValues(new Uint8Array(32)),\n                rp: { id: rpId, name: rpName },\n                user: {\n                    id: userId,\n                    name: displayName || `user-${Date.now()}`,\n                    displayName: displayName || \"BlazorPRFBase User\"\n                },\n                pubKeyCredParams: [\n                    { type: \"public-key\", alg: -7 },   // ES256\n                    { type: \"public-key\", alg: -257 }  // RS256\n                ],\n                authenticatorSelection: {\n                    residentKey: \"preferred\",\n                    userVerification: \"preferred\"\n                },\n                extensions: {\n                    prf: {}\n                } as AuthenticationExtensionsClientInputs\n            }\n        }) as PublicKeyCredential | null;\n\n        if (!credential) {\n            return JSON.stringify({ success: false, error: \"Registration cancelled\" });\n        }\n\n        const extensions = credential.getClientExtensionResults() as { prf?: { enabled?: boolean } };\n\n        if (!extensions.prf?.enabled) {\n            return JSON.stringify({ success: false, error: \"PRF extension not supported by authenticator\" });\n        }\n\n        return JSON.stringify({\n            success: true,\n            credentialId: bytesToBase64(new Uint8Array(credential.rawId))\n        });\n    } catch (e) {\n        return JSON.stringify({ success: false, error: (e as Error).message });\n    }\n}\n\n// ============================================================\n// WEBAUTHN PRF AUTHENTICATION + KEY DERIVATION & CACHING\n// ============================================================\n\n/**\n * Authenticate with a specific credential, derive keys, and cache them.\n * @param credentialIdBase64 The credential ID from registration\n * @param saltBase64 Salt for key derivation (also used as cache key)\n * @param ttlMs Optional TTL in milliseconds (null = no expiration)\n * @returns JSON with public key only (private keys stay in JS)\n */\nexport async function authenticate(\n    credentialIdBase64: string,\n    saltBase64: string,\n    ttlMs: number | null\n): Promise<string> {\n    try {\n        const credentialId = base64ToBytes(credentialIdBase64);\n        const salt = base64ToBytes(saltBase64);\n\n        const credential = await navigator.credentials.get({\n            publicKey: {\n                challenge: crypto.getRandomValues(new Uint8Array(32)),\n                rpId: window.location.hostname,\n                allowCredentials: [{\n                    type: \"public-key\",\n                    id: credentialId\n                }],\n                userVerification: \"preferred\",\n                extensions: {\n                    prf: {\n                        eval: {\n                            first: salt\n                        }\n                    }\n                } as AuthenticationExtensionsClientInputs\n            }\n        }) as PublicKeyCredential | null;\n\n        if (!credential) {\n            return JSON.stringify({ success: false, error: \"Authentication cancelled\" });\n        }\n\n        return await deriveAndCacheKeys(credential, saltBase64, ttlMs);\n    } catch (e) {\n        return JSON.stringify({ success: false, error: (e as Error).message });\n    }\n}\n\n/**\n * Authenticate with discoverable credential (user selects).\n * @param saltBase64 Salt for key derivation (also used as cache key)\n * @param ttlMs Optional TTL in milliseconds (null = no expiration)\n * @returns JSON with credential ID and public key only\n */\nexport async function authenticateDiscoverable(\n    saltBase64: string,\n    ttlMs: number | null\n): Promise<string> {\n    try {\n        const salt = base64ToBytes(saltBase64);\n\n        const credential = await navigator.credentials.get({\n            publicKey: {\n                challenge: crypto.getRandomValues(new Uint8Array(32)),\n                rpId: window.location.hostname,\n                userVerification: \"preferred\",\n                extensions: {\n                    prf: {\n                        eval: {\n                            first: salt\n                        }\n                    }\n                } as AuthenticationExtensionsClientInputs\n            }\n        }) as PublicKeyCredential | null;\n\n        if (!credential) {\n            return JSON.stringify({ success: false, error: \"Authentication cancelled\" });\n        }\n\n        return await deriveAndCacheKeys(credential, saltBase64, ttlMs);\n    } catch (e) {\n        return JSON.stringify({ success: false, error: (e as Error).message });\n    }\n}\n\n/**\n * Derive keys from PRF output and store as non-extractable CryptoKey objects.\n */\nasync function deriveAndCacheKeys(\n    credential: PublicKeyCredential,\n    saltBase64: string,\n    ttlMs: number | null\n): Promise<string> {\n    const extensions = credential.getClientExtensionResults() as {\n        prf?: { results?: { first?: ArrayBuffer } }\n    };\n\n    const prfOutput = extensions.prf?.results?.first;\n    if (!prfOutput) {\n        return JSON.stringify({ success: false, error: \"PRF output not available\" });\n    }\n\n    const prfBytes = new Uint8Array(prfOutput);\n    const credentialIdBase64 = bytesToBase64(new Uint8Array(credential.rawId));\n\n    // Import PRF output as HKDF key material\n    const keyMaterial = await crypto.subtle.importKey(\n        \"raw\",\n        prfBytes,\n        \"HKDF\",\n        false,\n        [\"deriveBits\", \"deriveKey\"]\n    );\n\n    // Derive AES-256-GCM key directly as non-extractable CryptoKey\n    const encryptionKey = await crypto.subtle.deriveKey(\n        {\n            name: \"HKDF\",\n            hash: \"SHA-256\",\n            salt: new TextEncoder().encode(\"BlazorPRFBase-encryption\"),\n            info: new TextEncoder().encode(\"aes-gcm-key\")\n        },\n        keyMaterial,\n        { name: \"AES-GCM\", length: 256 },\n        false,  // NOT extractable\n        [\"encrypt\", \"decrypt\"]\n    );\n\n    // Derive Ed25519 seed bits for signing key\n    const signingKeyBits = await crypto.subtle.deriveBits(\n        {\n            name: \"HKDF\",\n            hash: \"SHA-256\",\n            salt: new TextEncoder().encode(\"BlazorPRFBase-signing\"),\n            info: new TextEncoder().encode(\"ed25519-seed\")\n        },\n        keyMaterial,\n        256\n    );\n\n    // Import as Ed25519 private key (non-extractable)\n    const signingKeyBytes = new Uint8Array(signingKeyBits);\n    const pkcs8Key = wrapSeedInPkcs8(signingKeyBytes);\n    const signingKey = await crypto.subtle.importKey(\n        \"pkcs8\",\n        pkcs8Key,\n        { name: \"Ed25519\" },\n        false,  // NOT extractable\n        [\"sign\"]\n    );\n\n    // Get public key (we need extractable temporarily just to get public key)\n    const tempSigningKey = await crypto.subtle.importKey(\n        \"pkcs8\",\n        pkcs8Key,\n        { name: \"Ed25519\" },\n        true,  // extractable to get public key\n        [\"sign\"]\n    );\n    const jwk = await crypto.subtle.exportKey(\"jwk\", tempSigningKey);\n    const publicKeyBase64 = base64UrlToBase64(jwk.x!);\n\n    // Clear sensitive key material from memory\n    signingKeyBytes.fill(0);\n    pkcs8Key.fill(0);\n\n    // Clear any existing entry for this salt\n    clearCacheEntry(saltBase64);\n\n    // Cache the keys\n    keyCache.set(saltBase64, {\n        encryptionKey,\n        signingKey,\n        publicKeyBase64,\n        credentialIdBase64,\n        expiresAt: null,\n        expirationTimer: null\n    });\n\n    // Schedule expiration if TTL provided\n    if (ttlMs !== null && ttlMs > 0) {\n        scheduleExpiration(saltBase64, ttlMs);\n    }\n\n    // Return only public information - private keys stay in JS\n    return JSON.stringify({\n        success: true,\n        credentialId: credentialIdBase64,\n        publicKey: publicKeyBase64\n    });\n}\n\n// ============================================================\n// CACHE MANAGEMENT\n// ============================================================\n\n/**\n * Check if keys are cached for the given salt.\n */\nexport function hasCachedKeys(saltBase64: string): boolean {\n    const entry = keyCache.get(saltBase64);\n    if (!entry) {\n        return false;\n    }\n    // Check expiration\n    if (entry.expiresAt !== null && Date.now() > entry.expiresAt) {\n        clearCacheEntry(saltBase64);\n        return false;\n    }\n    return true;\n}\n\n/**\n * Get cached public key and credential ID (no private key exposure).\n */\nexport function getCachedPublicInfo(saltBase64: string): string {\n    const entry = keyCache.get(saltBase64);\n    if (!entry) {\n        return JSON.stringify({ success: false, error: \"No cached keys\" });\n    }\n    if (entry.expiresAt !== null && Date.now() > entry.expiresAt) {\n        clearCacheEntry(saltBase64);\n        return JSON.stringify({ success: false, error: \"Keys expired\" });\n    }\n    return JSON.stringify({\n        success: true,\n        credentialId: entry.credentialIdBase64,\n        publicKey: entry.publicKeyBase64\n    });\n}\n\n/**\n * Clear cached keys for the given salt.\n */\nexport function clearCachedKeys(saltBase64: string): void {\n    clearCacheEntry(saltBase64);\n}\n\n/**\n * Clear all cached keys.\n */\nexport function clearAllCachedKeys(): void {\n    for (const salt of keyCache.keys()) {\n        clearCacheEntry(salt);\n    }\n}\n\n// ============================================================\n// AES-256-GCM SYMMETRIC ENCRYPTION (using cached keys)\n// ============================================================\n\n/**\n * Encrypt plaintext using cached AES-GCM key.\n * @param plaintextBase64 Base64-encoded plaintext\n * @param saltBase64 Salt identifying the cached key\n * @returns JSON with ciphertext and nonce (both Base64)\n */\nexport async function encryptAesGcm(plaintextBase64: string, saltBase64: string): Promise<string> {\n    try {\n        const entry = keyCache.get(saltBase64);\n        if (!entry) {\n            return JSON.stringify({ success: false, error: \"No cached encryption key - authenticate first\" });\n        }\n        if (entry.expiresAt !== null && Date.now() > entry.expiresAt) {\n            clearCacheEntry(saltBase64);\n            return JSON.stringify({ success: false, error: \"Keys expired - re-authenticate\" });\n        }\n\n        const plaintext = base64ToBytes(plaintextBase64);\n        const nonce = crypto.getRandomValues(new Uint8Array(12));\n\n        const ciphertext = await crypto.subtle.encrypt(\n            { name: \"AES-GCM\", iv: nonce },\n            entry.encryptionKey,\n            plaintext\n        );\n\n        return JSON.stringify({\n            success: true,\n            ciphertext: bytesToBase64(new Uint8Array(ciphertext)),\n            nonce: bytesToBase64(nonce)\n        });\n    } catch (e) {\n        return JSON.stringify({ success: false, error: (e as Error).message });\n    }\n}\n\n/**\n * Decrypt ciphertext using cached AES-GCM key.\n * @param ciphertextBase64 Base64-encoded ciphertext (includes auth tag)\n * @param nonceBase64 Base64-encoded 12-byte nonce\n * @param saltBase64 Salt identifying the cached key\n * @returns JSON with plaintext or error\n */\nexport async function decryptAesGcm(\n    ciphertextBase64: string,\n    nonceBase64: string,\n    saltBase64: string\n): Promise<string> {\n    try {\n        const entry = keyCache.get(saltBase64);\n        if (!entry) {\n            return JSON.stringify({ success: false, error: \"No cached encryption key - authenticate first\" });\n        }\n        if (entry.expiresAt !== null && Date.now() > entry.expiresAt) {\n            clearCacheEntry(saltBase64);\n            return JSON.stringify({ success: false, error: \"Keys expired - re-authenticate\" });\n        }\n\n        const ciphertext = base64ToBytes(ciphertextBase64);\n        const nonce = base64ToBytes(nonceBase64);\n\n        // Validate nonce length (must be 12 bytes for AES-GCM)\n        if (nonce.length !== 12) {\n            return JSON.stringify({ success: false, error: \"Invalid nonce length - must be 12 bytes\" });\n        }\n\n        const plaintext = await crypto.subtle.decrypt(\n            { name: \"AES-GCM\", iv: nonce },\n            entry.encryptionKey,\n            ciphertext\n        );\n\n        return JSON.stringify({\n            success: true,\n            plaintext: bytesToBase64(new Uint8Array(plaintext))\n        });\n    } catch {\n        return JSON.stringify({ success: false, error: \"Decryption failed - authentication tag mismatch or wrong key\" });\n    }\n}\n\n// ============================================================\n// ED25519 DIGITAL SIGNATURES (using cached keys)\n// ============================================================\n\n/**\n * Sign a message using cached Ed25519 key.\n * @param messageBase64 Base64-encoded message\n * @param saltBase64 Salt identifying the cached key\n * @returns JSON with signature or error\n */\nexport async function ed25519Sign(messageBase64: string, saltBase64: string): Promise<string> {\n    try {\n        const entry = keyCache.get(saltBase64);\n        if (!entry) {\n            return JSON.stringify({ success: false, error: \"No cached signing key - authenticate first\" });\n        }\n        if (entry.expiresAt !== null && Date.now() > entry.expiresAt) {\n            clearCacheEntry(saltBase64);\n            return JSON.stringify({ success: false, error: \"Keys expired - re-authenticate\" });\n        }\n\n        const message = base64ToBytes(messageBase64);\n\n        const signature = await crypto.subtle.sign(\n            { name: \"Ed25519\" },\n            entry.signingKey,\n            message\n        );\n\n        return JSON.stringify({\n            success: true,\n            signature: bytesToBase64(new Uint8Array(signature))\n        });\n    } catch (e) {\n        return JSON.stringify({ success: false, error: (e as Error).message });\n    }\n}\n\n/**\n * Verify an Ed25519 signature.\n * @param messageBase64 Base64-encoded message\n * @param signatureBase64 Base64-encoded 64-byte signature\n * @param publicKeyBase64 Base64-encoded 32-byte public key\n * @returns true if valid, false otherwise\n */\nexport async function ed25519Verify(\n    messageBase64: string,\n    signatureBase64: string,\n    publicKeyBase64: string\n): Promise<boolean> {\n    try {\n        const message = base64ToBytes(messageBase64);\n        const signature = base64ToBytes(signatureBase64);\n        const publicKeyBytes = base64ToBytes(publicKeyBase64);\n\n        const publicKey = await crypto.subtle.importKey(\n            \"raw\",\n            publicKeyBytes,\n            { name: \"Ed25519\" },\n            false,\n            [\"verify\"]\n        );\n\n        return await crypto.subtle.verify(\n            { name: \"Ed25519\" },\n            publicKey,\n            signature,\n            message\n        );\n    } catch {\n        return false;\n    }\n}\n\n// ============================================================\n// UTILITY FUNCTIONS\n// ============================================================\n\n/**\n * Check if PRF extension is likely supported.\n */\nexport function isPrfSupported(): boolean {\n    return typeof PublicKeyCredential !== \"undefined\" &&\n        typeof navigator.credentials !== \"undefined\";\n}\n\n/**\n * Check if conditional mediation (passkey autofill) is available.\n * Returns true if the browser supports passkey autofill UI.\n */\nexport async function isConditionalMediationAvailable(): Promise<boolean> {\n    if (typeof PublicKeyCredential === \"undefined\") {\n        return false;\n    }\n    if (typeof PublicKeyCredential.isConditionalMediationAvailable !== \"function\") {\n        return false;\n    }\n    return await PublicKeyCredential.isConditionalMediationAvailable();\n}\n\n/**\n * Wrap Ed25519 seed in PKCS8 format.\n */\nfunction wrapSeedInPkcs8(seed: Uint8Array): Uint8Array {\n    const pkcs8Header = new Uint8Array([\n        0x30, 0x2e, 0x02, 0x01, 0x00, 0x30, 0x05, 0x06,\n        0x03, 0x2b, 0x65, 0x70, 0x04, 0x22, 0x04, 0x20\n    ]);\n    const pkcs8Key = new Uint8Array(pkcs8Header.length + seed.length);\n    pkcs8Key.set(pkcs8Header);\n    pkcs8Key.set(seed, pkcs8Header.length);\n    return pkcs8Key;\n}\n\nfunction bytesToBase64(bytes: Uint8Array): string {\n    let binary = \"\";\n    for (let i = 0; i < bytes.length; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n\nfunction base64ToBytes(base64: string): Uint8Array {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n\nfunction base64UrlToBase64(base64url: string): string {\n    return base64url\n        .replace(/-/g, \"+\")\n        .replace(/_/g, \"/\")\n        .padEnd(base64url.length + (4 - base64url.length % 4) % 4, \"=\");\n}\n\n// Export for .NET JSImport\nexport const BlazorPRFBase = {\n    isPrfSupported,\n    isConditionalMediationAvailable,\n    register,\n    authenticate,\n    authenticateDiscoverable,\n    hasCachedKeys,\n    getCachedPublicInfo,\n    clearCachedKeys,\n    clearAllCachedKeys,\n    encryptAesGcm,\n    decryptAesGcm,\n    ed25519Sign,\n    ed25519Verify,\n    setKeyExpiredCallback\n};\n"],
  "mappings": "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",
  "names": []
}
